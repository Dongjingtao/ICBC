# Git/Gitlab使用说明

## 背景介绍

如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？

Git是目前世界上最先进的分布式版本控制系统（没有之一）。

Linus在1991年创建了开源的Linux，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！

2005年Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub。

随着分布式部署和中台服务的概念逐步落地，对软件开发的源代码质量要求逐步提高，开发过程中多人协作的范围也逐步扩大，在开发运维整个过程中，需要有一整套的管理手段。目前开源社区围绕Git形成的一整套发布分享协作机制，是非常值得借鉴的。

- 围绕Git逐步建立的生态上是目前最佳的大范围合作实践。
  - Git比较有效的解决了权威性和自由度之间的矛盾。
- Git不再是一个单纯的源代码管理软件。
  - Github已经是一个社交场所。
- Git生态比较有效的解决了线上和线下一体化的问题。
  - 线下高效编辑输出，线上快速浏览方便审核。



所以本次培训，所有的资料都保存在Git上，所有作业的提交也都通过Git进行。



### Git和CVS/SVN的区别

Linus一直痛恨的CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统。

和集中式版本控制系统相比，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。

CVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。

微软自己也有一个集中式版本控制系统叫VSS，连微软自己都不好意思用了。

同样是开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。

### git/github/gitlab的区别

在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。

Git 是一个版本控制系统，可以视为一种协议。

GitHub 和 GitLab 都是基于 web 的 Git 仓库，使用起来二者差不多，它们都提供了分享开源项目的平台。

GitHub是一个网站，Github已成为全球最大的代码开源社区，国内类似的还有码云(gitee)，虽然github自己没有开源。

GitLab是一个开源产品，可以在企业内部建立一个私有的Git中央服务器。目前在行内主要使用gitlab。



## 行内环境

### 主要工具

目前行内主要使用以下工具

- git-bash，其他图形化工具都不好用的时候直接拍命令。
  
    - git官方的命令行工具，能够提供最完整的功能。最难用也最强大。有个很简陋的图形化界面。
- 虽然互联网上大部分git教程都是基于git-bash的命令行，个人认为还是尽量使用图形化界面。

- 专用的git客户端，比较好用比较强大。
    - tortoiseGit，需要依赖git-bash，能够提供比较完整的图形化界面，和资源管理器鼠标右键集成。
    - SourceTree：另外一个免费专用的git客户端。

- IDE集成了GIT客户端，一般集成了最常用的操作。
    - eclipse 4.x：默认使用Git。
    - vscode:前端常用



### 行内Gitlab服务端

git是一个分布式的系统，它工作的时候可以没有远程服务器，也可以同时向多个远程服务器进行同步。

- 杭研的gitlab：gitlab.sd.icbc 权限使用行内统一认证。


- 上海分行自己的gitlab：107.6.61.139:3080 直接注册账号。



### 行外Gitlab服务端

我们在互连网上搭建了一个gitlab服务，可以访问shfhlic.asuscomm.com:2020。

注意在互连网上所有的项目都设置为private，只有授权才可以访问，并且保证自己的密码有一定的强度。

此外公共的github和gitee也是比较常用的。




## Git基本操作补充说明

### 用户

Git中，用户和权限是分开管理的，通常git客户端会让用户提供姓名和邮箱。比如这样

```shell
$ git config --global user.name "Your Name"
$ git config --global user.email "email@example.com"
```

其他git客户端里面也会有相似的配置。

这里的用户名和邮箱并不用于权限管理，只是在git的服务端显示提交者的信息。目的是方便在不同权限管理的git服务端之间能够方便的识别同一个人。比如一个开发团队可以在github上使用同一个账户，但每个人都有自己不同的user.name，之后他们回到公司，在公司内部的gitlab上可以使用同样的user.name，但肯定会使用另外的账户权限进行工作。

比如同时使用杭州研发部和分行自己的gitlab的时候，在不同的服务端可以显示同样的姓名，就可以比较方便的追踪提交历史。

通常在互连网上使用github，会比较多推荐ssh+rsa的方式来进行权限控制，但在行内一般使用http+用户密码的方式来管理就足够了。

所以行内就推荐使用汉字真名和公网邮箱。

### 仓库

版本库又名仓库，英文名**repository**，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。

推荐在gitlab的服务端创建仓库，配制好权限，然后通过git的客户端clone到本地。

git的仓库并不需要和应用的项目一一对应，推荐一个仓库对应一个应用，并包含这个应用下多个不同但相关的项目（比如前端，后端，批量，甚至文档等等），这样更方便管理和维护。工作在一个应用下但不同代码项目上的开发人员可以比较方便的了解其他人员的工作情况，同时管理动作可以比较方便的实施。

比如对象存储仓库oss包含了三个项目，分行服务门户仓库包含了8个项目。

通常仓库可以设置为所有人可见，鼓励大家互相学习，但应该缩小写操作的授权。并不建议设置一个很全的组并且每次都赋予这个组一个很大的权限。



### 基本操作

基本日常操作通常都很好的集成在IDE中，一般这些操作和日常开发紧密集成，推荐在IDE里直接使用。典型包括

- 上传提交：commit/push

    - commit指提交到本地仓库。
    - push指推送到远程仓库，默认就是推送到原来匹配的远程仓库和分支。
    - 图形界面上的push...通常可以指定推送到远端不同的仓库或者分支。
- 下载：fetch/pull
    - fetch指拉取远程仓库的内容到本地仓库
    - pull实际是fetch+merge，表示拉取到本地仓库后，再和工作区的内容合并。
    - 图形界面上的pull...通常就是指可以从其他仓库或者分支拉取内容。
    - 如果存在多人协作，每次动手改代码之前，pull一下是一个良好的习惯。
- 合并：merge
    - 合并仓库的内容和你当前的内容，如果你不清楚发生了什么，不要贸然操作。
    - 通常情况下都可以自动合并，并不需要主动操作merge，操作pull命令就足够了。
    - **如果发生冲突自动合并失败，在没有搞清楚是什么原因的时候，不要手工强制合并。应当查询commit历史纪录联系相关人员，搞清楚发生了什么再做决定。**

#### eclipse4.x

以常见的eclipse 4.x界面为例：

![workspace_explor](Git%E5%92%8CGitlab%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.assets/workspace_explor.png)

一般项目右键弹出Team菜单就是git操作界面
![image-20191219135434448](Git%E5%92%8CGitlab%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.assets/image-20191219135434448.png)

#### TortoiseGit

资源管理器空白处右键，Git Clone

![image-20191220163540983](Git%E5%92%8CGitlab%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.assets/image-20191220163540983.png)

已经clone的仓库上右键

![image-20191220163742323](Git%E5%92%8CGitlab%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.assets/image-20191220163742323.png)




Git本地仓库保存密码，部分git客户端需要手工配置

```properties
[credential]

helper = store
```



#### vsCode

![image-20191220164545713](Git%E5%92%8CGitlab%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.assets/image-20191220164545713.png)


vscode提交信息只能写一行，理论上并不符合提交的规范，复杂的提交信息建议用专用工具书写
### Git提交(commit)信息书写规范


commit type填写格式规范如下

```html
< type > ( < scope > ): < subject > 

空一行

< body >

< footer >
```

比如这样写

![image-20191219135806384](Git%E5%92%8CGitlab%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.assets/image-20191219135806384.png)



#### type格式

type可以为以下内容之一： feat/fix/docs/style/refactor/test/chore

- feat:表示功能更新 feature
- fix:表示修改bug
- docs:表示修改文档
- style:通常表示修改界面
- refactor：表示重构了功能，但外部界面接口不变
- test:表示更新了测试用例
- chore:表示杂项更新，比如maven脚本，编译参数等等

#### scope格式

表示变更影响范围，选填

#### subject格式

变更的简要描述，30个字以内

##### **题目和正文之间要空一行**

#### body格式

变更的详细描述，可以写很多

#### footer脚注格式

最后一行，变更的脚注 BREAKING CHANGE/CLOSE ISSUE。


通常关闭issue的说明写在这里。



比如这次修改了部分文档，提交的时候说明可以着么写。

![image-20191218163622304](Git%E5%92%8CGitlab%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.assets/image-20191218163622304.png)
在服务端显示为
![image-20191218163517149](Git%E5%92%8CGitlab%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.assets/image-20191218163517149.png)

## Gitlab多人协作

### 分支操作

通常在git中，具体的开发动作都是在分支下完成的。这部分操作除了同步删除分支，其他在IDE中都有很好的集成。

- 分支的创建合并删除等操作建议在gitlab服务端进行操作，开发者客户端建议只是被动同步服务端的变化。
  - 先fetch，从远程仓库拉取分支内容至本地仓库，然后切换switch工作区到这个分支上。


- 至少主分支应该是受保护的，开发人员不能随意修改。
- 下级分支向上级分支合并，建议走MergeRequest代码审查流程。


- 在服务端删除分支后，客户端可以执行如下命令同步本地仓库的分支(需要git-bash)：

    - git remote prune origin  

- 如果没有专门的生产分支，则只向master分支合并经过生产验证的代码。在生产需要回退的时候，只需要check主分支的内容即可。

**分支不仅仅是开发源代码上的概念，也是管理上的概念，对于软件开发大量的管理工作都是基于分支来实现的。**

**在项目管理中，将不同的任务工作分配到不同的分支上，通过观察分支的行为，来对开发任务进度和质量进行管理，是比较可行的方案。**

![gitlab_flow (1)](Git%E5%92%8CGitlab%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.assets/gitlab_flow%20(1).png)



虽然实际开发过程中可能会做一些剪裁，但新功能需要在独立的分支中进行开发是被普遍接受的。

### Gitlab多人协作：MergeRequest（PullRequest）

在比较大和复杂的项目中，向上级分支合并不同开发人员的代码通常是需要授权的，这种授权经常和代码审查同时进行。

这种代码合并在gitlab中被称为MergeRequest，而在github网站里，通常被称为PR即PullRequest。

这类操作通常在gitlab的服务端进行。

主要工作流程

1. 从上级分支创建下级分支，上级分支具有写保护。
2. 开发人员在下级分支上进行开发。
3. 开发人员需要定期从上级分支pull，获取其他人的更新。
4. **当开发完毕后，开发人员在本分支push代码，在gitlab服务端发起mergeRequest。**
5. **上级分支管理员进行代码审核，合并下级分支的代码至上级分支。**
6. 如有需要，管理员在合并分支的时候同时删除下级分支。开发人员同步删除本地下级分支。

![image-20191224110727674](Git%E5%92%8CGitlab%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.assets/image-20191224110727674.png)

### Gitlab多人协作：Fork

多人协作的时候，除了可以在原始仓库中创建分支进行开发之外，还可以复制并创建一个新的仓库进行开发，即fork。

在互连网上，互不相识的开发人员协作往往采用这种方案，通常原始项目的维护人员并不会允许你在他的仓库里面随意操作，比如建很多分支。

在行内环境，通常并不需要这么做，如果你想做某些尝试但又不想打扰原来项目的维护人员，也不打算将代码合并回原来的仓库，可以采用这种方式。

![fork](Git%E5%92%8CGitlab%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.assets/fork.jpg)

### Gitlab多人协作:issue（工单）

在工作中主要将项目的任务使用 issue 体现：

- 从 issue 的 Board 上可以观察到 issue 进行到哪个流程。

- issue 关联MileStone 后，通过 MileStone 可以体现项目阶段性的进展，这是项目任务及流程的方面；

- issue 关联的 Merge Request 可以观察 issue 关联分支的代码变化，代码比对当然也可以在平台上进行，甚至可以对代码进行 Review 以及在相应代码片段进行备注。


作为一名 coder 执行的 issue 多数为代码任务，issue 可以通过创建关联的 Merge Request 和 branch 关联上代码，了解到当前工作的具体内容。

Issue 指的是一项待完成的工作，通常与系统的改进相关，中文可以译为问题或事务。下面这些都是 Issue 的例子：

- 一个软件的 bug。
- 一项功能建议。
- 一项待完成的任务。
- 文档缺失的报告。

在分行内部，一个issue可以是

- 一个维护
- 一个问题
- 立项中的一个子功能。

每个 Issue应该包含该问题的所有信息和历史，使得后来的人只看这个Issue，就能了解问题的所有方面和过程。

历史上，Issue起源于客服部门。用户打电话反映问题，客服就创建一个工单（ticket），后续的每一个处理步骤、每一次与用户的交流，都要更新工单，记录全部信息。这就是 Issue的前身。因此，Issue的原始功能是问题追踪和工单管理，后来不断扩展，逐渐演变成全功能的项目管理工具，还可以用于制定和实施软件的开发计划。

![image-20191224135000539](Git%E5%92%8CGitlab%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.assets/image-20191224135000539.png)

比如上文的3号issue已经逾期了。

#### WIP:work in progress

通过issue创建的mergeRequest会自动带上WIP标记，表示这个工单尚未完工，带有wip标记的mergerequest是无法被合并的，只有工单的施工者可以解除wip，表示工作已经结束，管理者可以进行代码合并。

![image-20191224134526677](Git%E5%92%8CGitlab%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.assets/image-20191224134526677.png)

![image-20191224134852069](Git%E5%92%8CGitlab%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.assets/image-20191224134852069.png)



### Gitlab多人协作:MileStone里程碑(立项)

里程碑用于安排问题并将请求合并到一个确定的组中，通过设置开始日期和到期日期，可以在指定的时间内完成。

Milestone可以当作一个立项，然后将实际的立项分解为多个issue，创建分支和mergeRequest，之后就可以比较方便的进行进度和质量管控。

<<<<<<< .merge_file_a09984
![image-20191224134339424](Git%E5%92%8CGitlab%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.assets/image-20191224134339424.png)
=======
![image-20191224134339424](Git%E5%92%8CGitlab%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.assets/image-20191224134339424.png)



### 操作issue和merge request的典型步骤

创建Issue通常都是项目经理来实施，通常和指定项目计划同步进行。

点击new issue

![image-20200214220217703](C:\Users\great\AppData\Roaming\Typora\typora-user-images\image-20200214220217703.png)

具体创建Issue的页面设置如下

![image-20200214221333509](Git%E5%92%8CGitlab%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.assets/image-20200214221333509.png)

assignee表示这件事情要谁干，比如这个issue是分配给 lich2(lich的马甲)来干的。

milestong归属到 **新员工自我介绍** 这个立项下面，due date表示要到 2月19日之前干完。



创建完毕之后，就可以在这个issue页面中创建 merge requst，这样的话这个合并请求是和这个issue相关联。

点击create merge request，选择 creat merge request and branch，将相关分支一起创建。

注意这里如果名字里有中文的话，通常需要自己重新编辑一下，页面有一些bug。**所以最好Issue起英文名字，和分支的名字保持一致！！！**

通常分支保持以一个数字编号开始。

source branch（源分支）一般都是master，多级分支管理就太复杂了。



![image-20200214221531358](Git%E5%92%8CGitlab%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.assets/image-20200214221531358.png)

之后就可以在新建的分支上进行修改开发。修改完毕之后，开发者点击 resolve，解除wip标志，告诉管理者该工作已经结束。

![image-20200217110224981](Git%E5%92%8CGitlab%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.assets/image-20200217110224981.png)

推荐管理者merge的时候勾选删除分支，自动清理服务端工作已经结束的分支。

之后相关issue也会自动关闭，关闭的issue可以重新打开reopen，并且可以重新创建merge request和同名的分支。



## 作业

在内部的gitlab服务器上注册用户 http://107.22.189.175:3080/，user.name使用本人汉字真名。

在本仓库中创建一个姓名+自我介绍的issue，并创建mergeRequest和同名分支，在分支中->自我介绍目录中创建以 自己名字+新员工介绍 命名的 md，完成后关闭wip标志，通知架构管理科导师合并。

之后fork 培训仓库，创建自己的私有仓库，私有仓库设置为private。

将培训导师添加到自己的私有仓库成为管理员。

后续作业和伪需求开发在私有仓库中进行，联系导师批改。

